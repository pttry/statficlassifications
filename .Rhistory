access_API(localID, content = "url")
}
get_url(localID)
get_url()
#' Get urls from API
#'
#' A wrapper for \code{access_API} function to get url.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return character,
#' @export
#'
#' @examples
get_url <- function(localID = NULL) {
if(is.null(localID)) {
localID <- paste0("/", localID)
}
access_API(localID, content = "url")
}
get_url()
localID <- paste0("/", localID)
localID
#' API interface
#'
#' Given a local ID of a correspondence table fetches the table and reads it.
#'
#' @param localID character local ID of the required correspondence table
#'
#' @return data.frame
#' @export
#'
#' @examples
access_API <- function(localID = NULL, content = "data") {
if(!(content %in% c("url", "data"))) {
stop("Argument 'content' has to be either 'data' or 'url'.")
}
if(!is.null(localID)) {
localID <- paste0("/", localID)
}
# Set url either ot get url or content
url <- paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables",
localID,
ifelse(content == "data", "/maps", ""))
# access API and return
as.data.frame(
jsonlite::fromJSON(
rawToChar(
httr::GET(
url,
query = list(content = content, meta = "min"))$content
)
)
)
}
#' Get urls from API
#'
#' A wrapper for \code{access_API} function to get url.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return character,
#' @export
#'
#' @examples
get_url <- function(localID = NULL) {
access_API(localID, content = "url")
}
get_url()
localID <- create_localID_name("kunta", "seutukunta", year = 2015)
get_url(localID)
#' API interface
#'
#' Given a local ID of a correspondence table fetches the table and reads it.
#'
#' @param localID character local ID of the required correspondence table
#'
#' @return data.frame
#' @export
#'
#' @examples
access_API <- function(localID = NULL, content = "data") {
if(!(content %in% c("url", "data"))) {
stop("Argument 'content' has to be either 'data' or 'url'.")
}
if(!is.null(localID)) {
localID <- paste0("/", localID)
}
# Set url either ot get url or content
url <- paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables",
localID,
ifelse(content == "data", "/maps", ""))
# access API and return
data.frame(
jsonlite::fromJSON(
rawToChar(
httr::GET(
url,
query = list(content = content, meta = "min"))$content
)
)
)
}
get_url(localID)
#' Get data from API
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return character
#' @export
#'
#' @examples
get_key <- function(localID) {
access_API(localID, content = "data")
}
get_key(localID)
#' Get urls from API
#'
#' A wrapper for \code{access_API} function to get url.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return character,
#' @export
#'
#' @examples
get_url <- function(localID = NULL) {
url <- access_API(localID, content = "url")
names(url) <- "url"
}
get_url(localID)
#' Get urls from API
#'
#' A wrapper for \code{access_API} function to get url.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return character,
#' @export
#'
#' @examples
get_url <- function(localID = NULL) {
url <- access_API(localID, content = "url")
names(url) <- "url"
url
}
get_url(localID)
endpoints <- get_url()
endpoints <- as.data.frame(sapply(endpoints, stringr::str_remove, paste0(url, "/")))
names(endpoints) <- "url"
endpoints <- get_url()
endpoints
endpoints <- get_url()
endpoints <- as.data.frame(sapply(endpoints, stringr::str_remove, paste0(url, "/")))
nros <- as.data.frame(matrix(unlist(lapply(endpoints, stringr::str_extract_all, "_\\d+_")), ncol = 2, byrow = TRUE))
names(nros) <- paste0("nro", 1:2)
results <- tidyr::separate(url, endpoint, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = substring(date1, 1,4),
date1 = substring(date1, 5,8),
year2 = substring(date2, 1,4),
date2 = substring(date2, 5,8))
results <- tidyr::separate(endpoints, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = substring(date1, 1,4),
date1 = substring(date1, 5,8),
year2 = substring(date2, 1,4),
date2 = substring(date2, 5,8))
results <- cbind(results, nros)
results
#' @param source character
#' @param target character
#' @param year integer
#' @param date character defaults to "0101" which the most correspondence tables have.
#'
#' @return character
#' @export
#'
#' @examples
#'
create_localID_name <- function(source, target,
year, year1 = year, year2 = year,
date1 = "0101", date2 = "0101",
nro1 = "_1_", nro2 = "_1_") {
paste0(source, nro1, as.character(year1), date1,"%23", target, nro2, as.character(year2), date2)
#paste0(source, "_1_", as.character(year), date, "%23", target, "_1_", as.character(year), date)
}
create_localID_name("kunta", "seutukunta", year = 2020)
create_localID_name_vct <- function(input_vector) {
source <- input_vector["source"]
target <- input_vector["target"]
year1 <- input_vector["year1"]
year2 <- input_vector["year2"]
nro1 <- input_vector["nro1"]
nro2 <- input_vector["nro2"]
paste0(source, nro1, as.character(year1), date1,"%23", target, nro2, as.character(year2), date2)
}
results[5,]
create_localID_name_vct <- function(input_vector) {
source <- input_vector["source"]
target <- input_vector["target"]
date1 <- input_vector("date1")
date2 <- input_vector("date2")
year1 <- input_vector["year1"]
year2 <- input_vector["year2"]
nro1 <- input_vector["nro1"]
nro2 <- input_vector["nro2"]
paste0(source, nro1, as.character(year1), date1,"%23", target, nro2, as.character(year2), date2)
}
results[5,]
urls <- get_url()
urls <- as.data.frame(sapply(urls, stringr::str_remove,
paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables/")))
nros <- as.data.frame(matrix(unlist(lapply(urls, stringr::str_extract_all, "_\\d+_")), ncol = 2, byrow = TRUE))
names(nros) <- paste0("nro", 1:2)
results <- tidyr::separate(urls, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = substring(date1, 1,4),
date1 = substring(date1, 5,8),
year2 = substring(date2, 1,4),
date2 = substring(date2, 5,8))
results <- cbind(results, nros)
results[4,]
create_localID_name(results[4])
create_localID_name(results[4,])
create_localID_name_vct(results[4,])
create_localID_name_vct <- function(input_vector) {
source <- input_vector["source"]
target <- input_vector["target"]
date1 <- input_vector["date1"]
date2 <- input_vector["date2"]
year1 <- input_vector["year1"]
year2 <- input_vector["year2"]
nro1 <- input_vector["nro1"]
nro2 <- input_vector["nro2"]
paste0(source, nro1, as.character(year1), date1,"%23", target, nro2, as.character(year2), date2)
}
create_localID_name_vct(results[4,])
#' @param source character
#' @param target character
#' @param year integer
#' @param date character defaults to "0101" which the most correspondence tables have.
#'
#' @return character
#' @export
#'
#' @examples
#'
create_localID_name <- function(source, target,
year, year1 = year, year2 = year,
date1 = "0101", date2 = "0101",
nro1 = "_1_", nro2 = "_1_",
input_vector = NULL) {
if(!is.null(input_vector)) {
source <- input_vector["source"]
target <- input_vector["target"]
date1 <- input_vector["date1"]
date2 <- input_vector["date2"]
year1 <- input_vector["year1"]
year2 <- input_vector["year2"]
nro1 <- input_vector["nro1"]
nro2 <- input_vector["nro2"]
}
paste0(source, nro1, as.character(year1), date1,"%23", target, nro2, as.character(year2), date2)
}
create_localID_name(input_vector = results[4,])
#' @param as_localID logical, whether returns the localID of the found table. Defaults to FALSE.
#'
#' @return
#' @export
#'
#' @examples
#'
#' # Browse all keys
#'    search_keys()
#'
search_keys <- function(...,
search_source = FALSE,
search_target = FALSE,
searchword_source = NULL,
searchword_target = NULL,
year = NULL,
as_localID = FALSE) {
urls <- get_url()
urls <- as.data.frame(sapply(urls, stringr::str_remove,
paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables/")))
nros <- as.data.frame(matrix(unlist(lapply(urls, stringr::str_extract_all, "_\\d+_")), ncol = 2, byrow = TRUE))
names(nros) <- paste0("nro", 1:2)
results <- tidyr::separate(urls, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = substring(date1, 1,4),
date1 = substring(date1, 5,8),
year2 = substring(date2, 1,4),
date2 = substring(date2, 5,8))
results <- cbind(results, nros)
# Filter results by the searchwords
searchwords <- unlist(list(...))
if(length(searchwords > 0)) {
results_temp <- data.frame()
for(word in searchwords) {
match_indicator_source <- NULL
match_indicator_target <- NULL
if(!search_target) {
match_indicator_source <- sapply(results$source, grepl, pattern = word)
}
if(!search_source) {
match_indicator_target <- sapply(results$target, grepl, pattern = word)
}
results_temp <- rbind(results_temp,
results[match_indicator_source,],
results[match_indicator_target,])
}
results <- results_temp
}
if(!is.null(year)) {
results <- dplyr::filter(results, year1 == year | year2 == year)
}
if(!is.null(searchword_source)) {
results <- dplyr::filter(results, grepl(searchword_source, source))
}
if(!is.null(searchword_target)) {
results <- dplyr::filter(results, grepl(searchword_target, target))
}
if(dim(results)[1] == 0) {
return("No search results!")
}
# Format output
output <- character(dim(results)[1])
if(as_localID) {
for(i in 1:dim(results)[1]) {
output[i] <- create_localID_name(input_vector = results[i,])
}
} else {
for(i in 1:dim(results)[1]) {
output[i] <- paste(results[i, "source"],
results[i, "year1"],
"->",
results[i, "target"],
results[i, "year1"], sep = " ")
}
}
output
}
search_keys("maakunta", as_localID = T)
search_keys("maakunta", as_localID = F)
search_keys("203cjtm33we")
search_keys("maakunta", as_localID = T) -> search_results
search_results
search_results[11] -> localID
get_key(localID)
#' Get data from API
#'
#' A wrapper for \code{access_API} to get data.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return data.frame
#' @export
#'
#' @examples
get_key <- function(localID) {
key <- access_API(localID, content = "data")
key <- data.frame(source_code = key$sourceItem$code,
source_name = unlist(lapply(key$sourceItem$classificationItemNames, '[', "name")),
target_code = key$targetItem$code,
target_name = unlist(lapply(key$targetItem$classificationItemNames, '[', "name")))
# There are encoding errors, fix these.
key <- fix_encoding(key)
key
}
get_key(localID)
search_keys()
localID <- search_keys(as_localID = T)[33]
localID
get_key(localID)
search_keys()
search_keys(as_localID)
search_keys(as_localID = T)
localID <- search_keys(as_localID)[156]
localID <- search_keys(as_localID = T)[156]
localID
get_key(localID)
get_key(search_keys(as_localID)[157])
get_key(search_keys(as_localID = TRUE)[157])
length(search_keys(as_localID = T))
search_keys(as_localID = T)[4:5]
search_keys(as_localID = T)[4:5] -> ids
#' Get data from API
#'
#' A wrapper for \code{access_API} to get data.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return data.frame
#' @export
#'
#' @examples
get_key <- function(localID) {
if(length(localID) > 1) {
stop("Multiple localIDs! This function currently gives you only one key at the time.")
}
key <- access_API(localID, content = "data")
key <- data.frame(source_code = key$sourceItem$code,
source_name = unlist(lapply(key$sourceItem$classificationItemNames, '[', "name")),
target_code = key$targetItem$code,
target_name = unlist(lapply(key$targetItem$classificationItemNames, '[', "name")))
# There may be encoding errors, fix these.
key <- fix_encoding(key)
key
}
get_key(ids)
ids
get_key(ids[1])
search_keys(searchword_source = "kunta", searchword_target = "maakunta", year = 2016)
search_keys(searchword_source = "kunta", searchword_target = "maakunta", year = 2016, as_localID = TRUE)
document()
devtools::document()
rm(list = ls())
library(devtools)
document8)
document()
help(search_keys)
create_localID_name("kunta", "maakunta", year = 2015)
create_localID_name("kunta", "maakunta", year = 2015) -> localID
result1 <- get_key(localID)
#' Get data from API
#'
#' A wrapper for \code{access_API} to get data.
#'
#' @param localID, character, local ID of the required correspondence table
#'
#' @return data.frame
#' @export
#'
#' @examples
get_key <- function(localID) {
if(length(localID) > 1) {
stop("Multiple localIDs! This function currently gives you only one key at the time.")
}
key <- access_API(localID, content = "data")
key <- data.frame(source_code = key$sourceItem$code,
source_name = sapply(key$sourceItem$classificationItemNames, '[', "name"),
target_code = key$targetItem$code,
target_name = sapply(key$targetItem$classificationItemNames, '[', "name"))
# There may be encoding errors, fix these.
key <- fix_encoding(key)
key
}
result2 <- get_key(localID)
identical(result1, result2)
head(result1)
head(result2)
help(get_key)
document()
rm(list = ls())
document()
check()
use_package("magrittr")
document()
chekc()
check()
4 magrittr::%>% rnorm()
use_package(stringr)
use_package("stringr")
use_package("tidyr")
document()
check()
document()
check()
document()
check()
load_all()
urls <- get_url()
load_all()
library(devtools)
load_all()
urls <- get_url()
urls <- as.data.frame(sapply(urls, stringr::str_remove,
paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables/")))
results <- tidyr::separate(urls, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = as.double(substring(date1, 1,4)),
year2 = as.double(substring(date2, 1,4)))
library(tidyverse)
results <- tidyr::separate(urls, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = as.double(substring(date1, 1,4)),
year2 = as.double(substring(date2, 1,4)))
results
max(c(results$year1, results$year2))
#' Get the year of the newest correspondence table
#'
#' @return double, the year of the newest correspondence table
#' @export
#'
#' @examples
get_latest_year <- function() {
urls <- get_url()
urls <- as.data.frame(sapply(urls, stringr::str_remove,
paste0("https://data.stat.fi/api/classifications/v2/correspondenceTables/")))
results <- tidyr::separate(urls, url, c("source", "temp_var", "date2"), sep = "_\\d+_") %>%
tidyr::separate(temp_var, c("date1", "target"), sep = "#") %>%
dplyr::mutate(year1 = as.double(substring(date1, 1,4)),
year2 = as.double(substring(date2, 1,4)))
max(c(results$year1, results$year2))
}
get_latest_year()
document()
rm(list = ls())
document()
load_all()
head(get_regionkey())
