% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_region_codes.R
\name{match_region_codes}
\alias{match_region_codes}
\alias{match_region_codes_internal}
\title{Match to potential region codes}
\usage{
match_region_codes(
  x,
  year = NULL,
  region_level = NULL,
  offline = TRUE,
  use_char_length_info = NULL
)

match_region_codes_internal(
  x,
  key,
  region_level = NULL,
  use_char_length_info = NULL
)
}
\arguments{
\item{x}{input code}

\item{year}{double, year of classification}

\item{region_level}{character (vector) region level of the input codes}

\item{offline}{logical, whether works offline with package data. Defaults to TRUE.}

\item{use_char_length_info}{TRUE or named vector, whether to use code character length
information in determining their region level. Defaults to NULL.}
}
\description{
Given a region code in "nonstandard" format, matches all "standardized" region
codes that it could denote. Works by first reducing the region code to a double
and then matching all region codes of all region levels that when reduced to
double are the same.
}
\details{
If given a region code in "standardized" format, returns the input as such. That is,
region codes in standardized format have unique matches.

By setting \code{year} you can restrict the domain of potential matches to region
codes in use in specific year. When \code{year} is not set, latest classifications
are used.

By setting \code{region_level} you can restrict the domain of potential matches
to specific region levels.
}
\section{Functions}{
\itemize{
\item \code{match_region_codes_internal()}: Match single region code. For internal use.

}}
